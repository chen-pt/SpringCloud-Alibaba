### springcloud-alibaba学习微服务

### 持久层采用的是SpringDataJPA
### JPA是Java Persistence API的简称，中文名为Java持久层API，是JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。

### shop-mommon  主要存放实体类
### shop-order   订单微服务
### shop-product 商品微服务
### shop-user    用户微服务

###   /**模拟下单**/
#####  架构演变  ####
# 前期没引入微服务思想之前，整个工程就是maven的多模块项目  oder服务想要调用 product服务 采用的就是远程调用 
# 服务之间硬编码的方式进行，假如1：商品服务挂了 将导致整个服务不可用 2：地址变更 需手动修改 3：服务增多后期维护复杂 4：如有多个服务提供者（集群）无法实现负载均衡
  
#  现在讨论微服务思想 
#  采用到的技术springcloud-alibaba 注册中心(nacos)、服务调用(feign)、负载均衡(ribbon)、断路器(Sentinel)、路由(zuul)  
# Nacos Discovery--服务治理（注册中心）
_**什么是服务治理？**_
    服务治理是微服务架构中最核心最基本的模块。用于实现各个微服务的自动化注册与发现。
**服务注册**：
    在服务治理框架中，都会构建一个注册中心，每个服务单元向注册中心登记自己提供服务的详细信息。并在注册中心形成一张服务的清单，服务注册中心需要以心跳的方式区监测
    清单中的服务是否可用，如果不可用，需要在服务清单中剔除不可用的服务。
**服务发现**：    
    服务调用方 向服务中心咨询服务，并获取所有服务的实例清单，实现对具体服务实例的访问
    
注册中心一般包含如下几个功能：
1. 服务发现：
    服务注册：保存服务提供者和服务调用者的信息
    服务订阅：服务调用者订阅服务提供者的信息，注册中心向订阅者推送提供者的信息
2. 服务配置：
    配置订阅：服务提供者和服务调用者订阅微服务相关的配置
    配置下发：主动将配置推送给服务提供者和服务调用者
3. 服务健康检测
    检测服务提供者的健康情况，如果发现异常，执行服务剔除    
    
    
#    CAP理论，一个分布式系统不可能同时满足C(Consistency 一致性)、A(Availability 可用性)、P(Partition Tolerance分区容错性)。
#            由于分区容错性在分布式系统中是必须要保证的，因此我们只能在A和C之间进行权衡 
#    nacos（AP）:
#    zookeeper（CP）:
#    eureka（AP）:
    
常见的注册中心 ？
Zookeeper
    zookeeper是一个分布式服务框架，是Apache Hadoop 的一个子项目，它主要是用来解决分布式
    应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。
Eureka
    Eureka是Springcloud Netflix中的重要组件，主要作用就是做服务注册和发现。但是现在已经闭源
Consul
    Consul是基于GO语言开发的开源工具，主要面向分布式，服务化的系统提供服务注册、服务发现
    和配置管理的功能。Consul的功能都很实用，其中包括：服务注册/发现、健康检查、Key/Value
    存储、多数据中心和分布式一致性保证等特性。Consul本身只是一个二进制的可执行文件，所以
    安装和部署都非常简单，只需要从官网下载后，在执行对应的启动脚本即可。
Nacos
    Nacos是一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。它是 Spring
    Cloud Alibaba 组件之一，负责服务注册发现和服务配置，可以这样认为nacos=eureka+config。 
    
    
本篇采用的是nacos  下面进行简单介绍
    Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。
    从上面的介绍就可以看出，nacos的作用就是一个注册中心，用来管理注册上来的各个微服务。
3.3.1 搭建nacos环境
第1步: 安装nacos
#下载地址: https://github.com/alibaba/nacos/releases
#下载zip格式的安装包，然后进行解压缩操作
第2步: 启动nacos
#切换目录
cd nacos/bin
#命令启动
startup.cmd -m standalone
第3步: 访问nacos
打开浏览器输入http://localhost:8848/nacos，即可访问服务， 默认密码是nacos/nacos



## 负载均衡
#什么是负载均衡？
-- 通俗的讲负载均衡就是将负载（工作任务、访问请求）进行分摊到多个操作单元（服务器、组件）上进行执行
-- 根据负载均衡发生位置的不同，一般分为服务端负载均衡与客户端负载均衡
-- 服务端负载均衡指的是发生在服务提供方，比如常见的nginx负载均衡
-- 客户端负载均衡指的是发生在服务请求的一方，也就是发送请求之前已经选好了由哪个实例处理请求

#  我们在微服务调用关系中一般会选择客户端负载均衡，也就是在服务调用的一方来决定服务由哪个提供者执行。


Ribbon负载均衡
    Ribbon是Spring Cloud的一个组件， 它可以让我们使用一个注解就能轻松的搞定负载均衡
Ribbon支持的负载均衡策略
    Ribbon内置了多种负载均衡策略,内部负载均衡的顶级接口为com.netflix.loadbalancer.IRule    
1：BestAvailableRule  选择一个最小的并发请求的server   
    逐个考察Server，如果Server被tripped了，则忽略，在选择其中ActiveRequestsCount最小的server 
2：AvailabilityFilteringRule  过滤掉那些因为一直连接失败的被标记为circuit tripped的后端server，并过滤掉那些高并发的的后端server（activeconnections 超过配置的阈值）   
    使用一个AvailabilityPredicate来包含过滤server的逻辑，其实就就是检查status里记录的各个server的运行状态 
3：WeightedResponseTimeRule  根据相应时间分配一个weight，相应时间越长，weight越小，被选中的可能性越低。    
    一个后台线程定期的从status里面读取评价响应时间，为每个server计算一个weight。Weight的计算也比较简单responsetime 减去每个server自己平均的responsetime是server的权重。当刚开始运行，没有形成statas
    时，使用roubine策略选择server。
4：RetryRule  对选定的负载均衡策略机上重试机制    
    在一个配置时间段内当选择server不成功，则一直尝试使用subRule的方式选择一个可用的server
5：RoundRobinRule  轮询方式轮询选择server    
    轮询index，选择index对应位置的server
6：RandomRule 随机选择一个server
    在index上随机，选择index对应位置的server    
7：ZoneAvoidanceRule   复合判断server所在区域的性能和server的可用性选择server 
    使用ZoneAvoidancePredicate和AvailabilityPredicate来判断是否选择某个server，前一个判断判定一个zone的运行性能是否可用，剔除不可用的zone（的所有server），AvailabilityPredicate用于过滤掉连接
    数过多的Server。


#### 基于Feign实现服务调用       
  什么是feign?
    Feign是是springcloud提供的一个声明式的伪Http客户端，它使得调用远程服务就像调用本地服务一样简单，只需创建一个接口并添加一个注解即可。
    Nacos很好的兼容了Feign，Feign默认集成了Ribbon，所以在Nacos下使用Feign默认就实现了负载均衡的效果。  
    
    
####  Sentinel 服务容错
   高并发带来的问题   
    在微服务架构中，我们将业务拆分成一个个的服务，服务与服务之间可以互相调用，但是由于网络原因或者自身原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现延迟，
    若此时有大量的网络涌入，会形成任务堆积，最终导致服务瘫痪。
    由于服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的雪崩效应。
    雪崩发生的原因多种多样，有不合理的容量设计，或者是高并发下某一个方法响应变慢，亦或是某台机器的资源耗尽。我们无法杜绝雪崩源头的发生，只有做好足够的容错，保证一个服务发生问题，
    不会影响到其他服务的正常运行。也就是"雪落而不雪崩"。
####   常见的容错方案
   常见的容错思路
        隔离、超时、限流、熔断、降级这几中  下面分别介绍一下
    隔离
        它是指系统按照一定的原则划分为若干个服务模块，各个模块之间相对独立，无强依赖。当有故障发生时，能将问题和影响隔离在某个模块内部，而不扩散风险，不波及其他模块，
        不影响整体的系统服务。常见的隔离方式有：线程池隔离、信号量隔离
    超时
        在上游服务调用下游服务的时候，设置一个最大响应时间，如果超过这个时间，下游未作反应，就断开请求，释放掉线程。
    限流
        限制系统的输入和输出流量从而达到保护系统的目的。为了保证系统的稳固运行，一旦达到需要限制的阈值，就需要限制流量并采取少量措施以完成限制流量的目的。
    熔断
        在互联网系统中，当下游服务因访问压力过大而响应变慢或失败，上游服务为了保护系统整体的可用性，可以暂时切断对下游服务的调用。这种牺牲局部，保全整体的措施就叫做熔断。
        熔断一般有三种状态
            熔断关闭状态
                服务没有故障时，熔断器所处的状态，对调用方的调用不做任何限制
            熔断开启状态
                后续对该服务接口的调用不再经过网络，直接执行本地的fallback方法
            半熔断状态
                尝试恢复服务调用，允许有限的流量调用该服务，并监控调用的成功率。如果成功率达到预期，则说明服务已恢复，进入熔断关闭状态；如果成功率依然很低，则重新进入熔断关闭状态
    降级
        降级其实就是为了服务提供一个托底的方案，一旦服务无法调用，就是用托底方案
                    
        
    
Gateway核心架构
基本概念
路由（route）是gateway中最基本的组件之一，表示一个具体的路由信息载体。主要定义了下面的几个信息    
id：路由标识符，区别于其他 Route。
uri：路由指向的目的地 uri，即客户端请求最终被转发到的微服务。
order：用于多个 Route 之间的排序，数值越小排序越靠前，匹配优先级越高。
predicate：断言的作用是进行条件判断，只有断言都返回真，才会真正的执行路由。
filter：过滤器用于修改请求和响应信息。

执行流程大体如下：
1. Gateway Client向Gateway Server发送请求
2. 请求首先会被HttpWebHandlerAdapter进行提取组装成网关上下文
3. 然后网关的上下文会传递到DispatcherHandler，它负责将请求分发给RoutePredicateHandlerMapping
4. RoutePredicateHandlerMapping负责路由查找，并根据路由断言判断路由是否可用
5. 如果过断言成功，由FilteringWebHandler创建过滤器链并调用
6. 请求会一次经过PreFilter--微服务--PostFilter的方法，最终返回响应